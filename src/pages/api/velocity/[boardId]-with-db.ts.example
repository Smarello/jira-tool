/**
 * Enhanced velocity API with database caching
 * Following Clean Architecture: Infrastructure integration
 */

import type { APIRoute } from 'astro';
import { getMcpAtlassianClient } from '../../../lib/mcp/atlassian';
import { calculateRealSprintsVelocity } from '../../../lib/velocity/calculator';
import { 
  createEnhancedVelocityData,
  type SprintVelocity 
} from '../../../lib/velocity/mock-calculator';
import { getDatabaseService } from '../../../lib/database/integration-example';

export const GET: APIRoute = async ({ params }) => {
  const boardId = params.boardId;
  
  if (!boardId || typeof boardId !== 'string') {
    return new Response(
      JSON.stringify({ error: 'Board ID is required' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  try {
    const mcpClient = getMcpAtlassianClient();
    const databaseService = getDatabaseService();

    // 1. Try to get cached closed sprints from database
    const cachedSprints = await databaseService.getCachedClosedSprints(boardId, 10);
    
    if (cachedSprints.length > 0) {
      // Use cached data for closed sprints
      const velocityData = createEnhancedVelocityData(
        boardId,
        `Board ${boardId}`, // Could be cached too
        cachedSprints.map(sprint => ({
          sprintId: sprint.id,
          sprintName: sprint.name,
          ...sprint.velocityData
        }))
      );

      return new Response(
        JSON.stringify({
          ...velocityData,
          fromCache: true,
          timestamp: new Date().toISOString()
        }),
        { 
          status: 200, 
          headers: { 'Content-Type': 'application/json' } 
        }
      );
    }

    // 2. Fallback to JIRA API for fresh data
    const sprintsResponse = await mcpClient.getBoardSprints(boardId);
    
    if (!sprintsResponse.success) {
      return new Response(
        JSON.stringify({ error: sprintsResponse.error || 'Failed to fetch sprints' }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // 3. Calculate velocity for all sprints
    const issuesApi = mcpClient.getIssuesApi();
    const sprintVelocities = await calculateRealSprintsVelocity(
      sprintsResponse.data, 
      issuesApi, 
      mcpClient
    );

    // 4. Save closed sprints to database for future use
    const closedSprints = sprintsResponse.data.filter(sprint => sprint.state === 'closed');
    
    for (const sprint of closedSprints) {
      const shouldRefresh = await databaseService.shouldRefreshFromJira(sprint.id, 24);
      
      if (shouldRefresh) {
        // Get issues for this sprint
        const sprintIssues = await issuesApi.fetchSprintIssues(sprint.id);
        
        // Find velocity data for this sprint
        const velocityData = sprintVelocities.find(v => v.sprintId === sprint.id);
        
        // Save to database
        await databaseService.saveClosedSprint(sprint, sprintIssues);
      }
    }

    // 5. Return fresh data
    const boardResponse = await mcpClient.getBoardInfo(boardId);
    const boardName = boardResponse.success ? boardResponse.data.name : `Board ${boardId}`;

    const velocityData = createEnhancedVelocityData(
      boardId,
      boardName,
      sprintVelocities
    );

    return new Response(
      JSON.stringify({
        ...velocityData,
        fromCache: false,
        timestamp: new Date().toISOString()
      }),
      { 
        status: 200, 
        headers: { 'Content-Type': 'application/json' } 
      }
    );

  } catch (error) {
    console.error('Velocity API error:', error);
    
    return new Response(
      JSON.stringify({ 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error'
      }),
      { 
        status: 500, 
        headers: { 'Content-Type': 'application/json' } 
      }
    );
  }
};
