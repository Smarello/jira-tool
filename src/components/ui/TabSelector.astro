---
/**
 * TabSelector Component
 * Reusable tab navigation component for switching between different views
 * Following Clean Code: Single responsibility, reusable UI component
 */

export interface Props {
  tabs: Array<{ id: string; label: string; disabled?: boolean }>;
  activeTab: string;
  class?: string;
}

const { tabs, activeTab, class: className } = Astro.props;
---

<div class={`border-b border-gray-200 ${className || ''}`}>
  <nav class="-mb-px flex space-x-8" role="tablist">
    {tabs.map(tab => (
      <button
        type="button"
        role="tab"
        aria-selected={activeTab === tab.id}
        aria-controls={`${tab.id}-panel`}
        class={`py-2 px-1 border-b-2 font-medium text-sm transition-colors duration-200
                ${activeTab === tab.id 
                  ? 'border-blue-500 text-blue-600' 
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                }
                ${tab.disabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer hover:border-gray-300'}`}
        data-tab-id={tab.id}
        disabled={tab.disabled}
        title={tab.disabled ? 'Not available' : `Switch to ${tab.label}`}
      >
        {tab.label}
      </button>
    ))}
  </nav>
</div>

<script>
  /**
   * Tab switching logic with custom events
   * Following Clean Code: Event-driven architecture, accessible interaction
   */
  
  // Handle tab clicks with event delegation
  document.addEventListener('click', (e) => {
    const button = e.target as HTMLElement;
    const tabButton = button.closest('[data-tab-id]') as HTMLButtonElement;
    
    if (tabButton && !tabButton.disabled) {
      const tabId = tabButton.dataset.tabId;
      if (tabId) {
        // Update visual state immediately for better UX
        updateTabVisualState(tabButton);
        
        // Dispatch custom event for parent components to handle
        document.dispatchEvent(new CustomEvent('tabChanged', { 
          detail: { tabId },
          bubbles: true 
        }));
      }
    }
  });
  
  // Handle keyboard navigation (Enter and Space)
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      const tabButton = e.target as HTMLElement;
      if (tabButton.hasAttribute('data-tab-id') && !tabButton.hasAttribute('disabled')) {
        e.preventDefault();
        tabButton.click();
      }
    }
    
    // Arrow key navigation
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      const currentTab = e.target as HTMLElement;
      if (currentTab.hasAttribute('data-tab-id')) {
        e.preventDefault();
        navigateToNextTab(currentTab, e.key === 'ArrowRight');
      }
    }
  });
  
  /**
   * Updates visual state of clicked tab
   * Following Clean Code: Single responsibility, immediate feedback
   */
  function updateTabVisualState(clickedButton: HTMLButtonElement) {
    const tabContainer = clickedButton.closest('[role="tablist"]');
    if (!tabContainer) return;
    
    // Remove active state from all tabs in this container
    const allTabs = tabContainer.querySelectorAll('[data-tab-id]');
    allTabs.forEach(tab => {
      tab.classList.remove('border-blue-500', 'text-blue-600');
      tab.classList.add('border-transparent', 'text-gray-500');
      tab.setAttribute('aria-selected', 'false');
    });
    
    // Add active state to clicked tab
    clickedButton.classList.remove('border-transparent', 'text-gray-500');
    clickedButton.classList.add('border-blue-500', 'text-blue-600');
    clickedButton.setAttribute('aria-selected', 'true');
  }
  
  /**
   * Navigate to next/previous tab using keyboard
   * Following Clean Code: Accessibility support, clear navigation
   */
  function navigateToNextTab(currentTab: HTMLElement, forward: boolean) {
    const tabContainer = currentTab.closest('[role="tablist"]');
    if (!tabContainer) return;
    
    const allTabs = Array.from(tabContainer.querySelectorAll('[data-tab-id]:not([disabled])'));
    const currentIndex = allTabs.indexOf(currentTab);
    
    if (currentIndex === -1) return;
    
    let nextIndex: number;
    if (forward) {
      nextIndex = currentIndex + 1 >= allTabs.length ? 0 : currentIndex + 1;
    } else {
      nextIndex = currentIndex - 1 < 0 ? allTabs.length - 1 : currentIndex - 1;
    }
    
    const nextTab = allTabs[nextIndex] as HTMLElement;
    nextTab.focus();
    nextTab.click();
  }
</script>

<style>
  /* Ensure smooth transitions and accessibility */
  [data-tab-id] {
    transition: all 0.2s ease;
  }
  
  [data-tab-id]:focus {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
  }
  
  [data-tab-id]:disabled {
    pointer-events: none;
  }
</style>